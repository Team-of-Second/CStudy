# OS
- [Process](#process)

***

# Process
### 프로세스(Process)
프로세스는 실행중에 있는 프로그램을 의미하며, 스케줄링의 대상이 되는 작업과 같은 의미로 쓰인다. 프로세스 내부에는 최소 하나의 스레드를 가지고 있고, 실제로는 스레드 단위로 스케줄링을 한다. 
하드디스크에 있는 프로그램을 실행하면 실행을 위해 메모리 할당이 이루어지고 할당된 메모리 공간이 바이너리 코드로 올라가게 된다. 이 순간부터 **프로세스**라 부른다.  


### 프로세스의 메모리구조
<img src="https://user-images.githubusercontent.com/80737266/166136565-59993a30-ab66-459d-a8f0-294878eb8a39.png" width="400" height="200"/>  

1. Code  영역 : 프로그램을 실행시키는 실행파일 내의 명령어들이 올라감. 소스코드가 올라가는 영역
2. Data  영역 : 전역변수, static 변수들이 할당받는 영역
3. Stack 영역 : 지역변수, 함수 호출 시 전달되는 인자를 위한 메모리영역
4. Heap  영역 : 동적할당을 위한 메모리영역 (C의 malloc, JAVA의 new 등)  

### 프로세스 관리
현대의 수많은 운영체제에서는 하나 이상의 프로그램이 동시에 메모리에 적재된다. 다중 프로그래밍 또는 멀티태스킹 운영체제는 동시에 여러 프로세스를 실행하는 시스템을 말한다. 즉, 프로세스를 관리하는 CPU는 하나인데 여러개의 프로세스를 관리할 필요가 있다.  이 때 요구되는 사항은 프로세스가 적절한 순간에 할당받고 해제되는 것이다. 이 때 여러 프로세스는 사실 동시에 실행되고 있는 것이 아닌, 고속으로 여러 프로세스를 **일정한 기준**으로 오가며 실행된다. 일정한 기준으로 CPU 할당 순서 및 방법을 결정하는 일을 [스케줄링]()이라고 한다.

### 프로세스 상태
프로세스는 메인 메모리에 할당되어 실행중인 상태인 프로그램을 말한다. 프로그램은 일반적으로는 하드디스크에 저장되어 아무 일도 하지 않는 상태이다. 프로세스는 실행되면서 stack, pointer, data, text, register 등이 끊임없이 변한다. 프로세스는 job, task라고 불리기도 한다. 프로세스의 진행 과정은 다음과 같다.    

<img src="https://user-images.githubusercontent.com/80737266/166438951-3f134aca-3296-435e-be66-b6bb6745b7f3.png"/>

위 그림은 **프로세스 상태 전이도**이다. 각 상태에 대한 설명은 다음과 같다.   

- New : 프로그램이 메인 메모리에 할당된다
- Ready : 할당된 프로그램이 초기화와 같은 작업을 통해 실행되기 위한 모든 준비를 마친다
- Running : CPU가 해당 프로세스를 실행한다
- Waiting : 프로세스가 끝나지 않은 시점에서 I/O로 인해 CPU를 사용하지 않고 다른 작업을 한다(해당 작업이 끝나면 다시 CPU에 의해 실행되기 위해 ready상태로 돌아감)
- Terminated : 프로세스가 완전히 종료된다

1. New -> Ready
프로세스는 생성과 동시에 Ready 상태로 들어간다. 프로그램을 실행시키면 바로 실행되는 것이 아니라 Ready 상태로 빠지게 되는데, 그 이유는 현재 CPU에 의해 임의의 프로세스가 실행중일 수 있기 때문이다. 
2. Ready -> Running
Ready 상태에 있는 프로세스들은 스케줄러에 의해 관리되는 프로세스들이다. 스케줄러는 Ready 상태에 있는 프로세스 중 하나를 선택하여 CPU에 실행될 수 있게 한다. Ready 상태에 있는 프로세스 중 스케줄러에 의해 선택된 프로세스는 Running 상태가 되어 실행된다.
3. Running -> Ready
프로세스에는 우선순위라는 개념이 존재하여 우선순위가 더 높은 프로세스가 존재한다면, 현재 프로세스를 Ready 상태로 변경한뒤 새로운 프로세스를 Running 으로 돌린다. 
4. Running -> Blocked
프로세스가 Block 상태가 되었다는 것은 실행을 멈추게 되었다는 의미이다. 보통 입출력에 관련된 일을 할 때 Block 상태에 빠지게 된다. 입출력을 할 때에는 시간이 많이 걸리고 CPU에 의해 프로세스가 실행될 수 없기 때문에 효율적 관리를 위해 입출력을 진행하는 프로세스는 Blocked 상태로 보내고 실행 가능한 프로세스를 Running 상태로 보낸다.
5. Waiting -> Ready
Blocked(Waiting) 상태는 스케줄러에 의해 선택될 수 없다. 이것이 Ready 상태와 가장 큰 차이점이다. Ready와 Blocked 모두 프로세스가 실행되지 않는 상태지만 Ready의 경우 당장이라도 실행 가능한 상태이지만 Blocked의 경우 스케줄러에 의해 선택받을 수 없다. 그렇기 때문에 파일 입출력이 완료된 프로세스는 Ready 상태로 빠져야 한다.

### 프로세스 제어 블록(Process Control Block)
PCB(Process Control Block)는 운영체제가 프로세스를 제어하기 위해 정보를 저장하는 곳으로, 프로세스의 상태 관리와 여러 프로세스를 오가는 문맥교환을 위해 필요하다. 프로세스가 생성될 때 고유한 PCB가 생성되고 프로세스가 완료되면 PCB도 함께 제거된다. 운영체제에 따라 PCB에 포함되는 정보는 다를 수 있지만, 일반적으로 아래와 같다. 

<img src="https://user-images.githubusercontent.com/80737266/166231782-4724268d-9836-4ac1-a5e8-b8f2a2fcefaf.png"/>  

- Pointer : 프로세스의 현재 위치를 저장하는 포인터 정보   
- Process State : 프로세스의 현재 상태를 저장. 상태에는 생성(New), 준비(Ready), 실행(Running), 대기(Waiting), 종료(Terminated)가 있음   
- Process Number : 모든 프로세스에는 프로세스 식별자를 저장하는 프로세스 ID 또는 PID라는 고유 번호가 할당됨   
- Program Counter : 프로그램을 위해 실행될 다음 명령어의 주소를 포함하는 카운터 저장
- Registers : 누산기, 베이스, 레지스터 및 범용 레지스터를 포함하는 CPU 레지스터에 있는 정보 저장
- Memory Limits : 운영 체제에서 사용하는 메모리 관리 시스템에 대한 정보 포함. 페이지 테이블, 세그먼트 테이블 등이 포함될 수 있음
- Open File Lists : 프로세스를 위해 열린 파일 목록 포함   

운영체제는 빠르게 PCB에 접근하기 위해 **프로세스 테이블**을 사용하여 각 프로세스의 PCB를 관리한다.

### 프로세스 간 통신(IPC) = Inter-Process Communication   
프로세스 간 통신을 한다는 의미는 데이터를 주고받는다는 것이다. 즉, 동시에 접근이 가능한 메모리가 있어야 한다는 의미이며 공유하는 메모리가 있어야 한다.  
공유 메모리, 파이프, 소켓, 메세지 큐, 메모리 맵, RPC(Remote Procedure Call) 의 방법이 있으며 자세한 내용은 링크 참고   
[프로세스간 통신](https://dar0m.tistory.com/233)   

### Question
❓ 프로그램 vs 프로세스   

❓ 프로세스의 특징   
<span style="color:white">
- 프로세스는 각각 독립된 메모리영역(Code ,Data, Stack, Heap)을 할당받는다
- 기본적으로 프로세스당 최소 1개의 스레드(메인 스레드)를 가지고 있다
- 각 프로세스는 별도의 주소 공간에서 실행되며 한 프로세스는 다른 프로세스의 변수나 자료구조에 접근할 수 없다
- 한 프로세스가 다른 프로세스의 자원에 접근하려면 프로세스간 통신(IPC, Inter Process Communication) 을 사용해야 한다(Ex. 파이프, 파일, 소켓 등을 이용한 통신방법)</span>   

❓ 멀티프로그래밍 vs 멀티프로세싱    
초기의 컴퓨터에서는 하나의 프로그램이 메모리에 올라가면 하나의 프로그램만 CPU가 처리를 진행할 수 있었다. 이 과정에서 프로세서의 처리 속도와 입출력 속도 간의 차이로 인해, 입출력이 완료될 때까지 프로세서는 idle한 상태가 된다. 따라서 이는 프로세서의 자원 낭비로 이루어진다. 프로세서가 입출력 작업의 종료를 대기할 동안 하나의 프로세서에서 다른 프로그램을 수행할 수 있도록 하는 것이 멀티프로그래밍이다.   
멀티 프로세싱은 다수의 프로세서가 서로 협력적으로 일을 처리하는 것을 의미한다.
컴퓨터는 1대인데 프로세서(CPU)는 2개 이상이다. 보통, 멀티코어시스템(multi-core system)을 포함한다.   

❓ 프로그램 간 통신이 스레드 간 통신보다 어려운 이유   
프로세스는 생성되면서 메모리 공간 등 별도의 자원을 할당하지만 스레드는 메모리 공간과 자원을 공유한다. 이것은 프로세스와 스레드의 정의에서 볼 수 있으며, 프로세스는 애초에 통신할 공간이 없기에 별도의 공간을 마련해주어야 하므로 당연히 더 어렵다. 

